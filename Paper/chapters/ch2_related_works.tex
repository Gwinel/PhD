\chapter{并发哈希表的相关研究}

% 引子

\section{哈希表概述}

\subsection{相关概念}

哈希表、树、链表等都属于搜索数据结构。
搜索数据结构由元素集合以及访问和操作这些元素的接口构成。
如果搜索数据结构能够被多个处理器共享，我们则称该数据结构为\textbf{并发搜索数据结构}(CSDS)。
哈希表（hash table），又名散列表，是一种应用广泛的搜索数据结构，它通过键值对（key-value）实现对关联数据的高效存取。
键值对之间的映射关系称为\textbf{哈希函数}。
一般的哈希表都提供了\textit{add(),remove()}和\textit{find()}三种操作的接口。
哈希表的操作分为\textbf{读}操作和\textbf{写}操作，其中读操作指哈希表的查询操作，写操作包括在哈希表中插入和删除元素。
哈希表和树型数据结构相比的最大的优势是哈希表的查询复杂度可以到常数级。
存放值的存储空间称为\textbf{哈希桶}（bucket）或者\textbf{哈希槽}（slot）。
哈希表中存放的元素的数量与哈希桶数量的比值称为\textbf{负载因子}（load factor).
哈希表使用哈希函数计算得到一个索引值，该索引值表明键对应的值在桶数组中的位置。
关于哈希函数，有一个最理想的原则：将每一个key映射到单独的哈希桶内。
但是，当数据集规模很大时，能够完美的践行上述原则的哈希函数并不存在。
因此在实际的映射过程中往往会出现多个key对应相同的索引值，这时称为发生了\textbf{碰撞}（collision）.
既然碰撞无法避免，那么我们能做的就是在设计哈希表的时候尽量的选择好的哈希函数。
一个好哈希函数的基本需求是输出的哈希值比较均匀。
这样可以使发生碰撞的概率最小化，同时使得各个bucket中碰撞的条目比较平均。
有国外的研究人员对已有的哈希函数做过比较~\cite{Josh2012}，结论是MurmurHash3~\cite{Murmurhash}~和CityHash~\cite{cityhash}~是迄今为止最出色的哈希函数。

\subsection{哈希函数}
哈希函数根据其应用场景可以划分成加密和非加密两类。
非加密的哈希函数通过数学运算将字符串转化成整型数输出。
哈希函数的一个重要特点是它的输出能够在可能的输出域内尽量的保证均匀分布，尤其是当具有比较相近的输入时，这种特性尤为可贵。
与加密哈希函数所不同的是，非加密哈希函数无法承担阻止攻击者利用碰撞进行攻击的任务。
非加密哈希函数的运算速度要比加密哈希函数快。
哈希表通常采用非加密哈希函数建立元素与哈希表的对应关系。

Bob Jenkins长期从事哈希函数的研究，他在1997年对哈希函数的研究中提出了被后来研究人员称为Jenkins的哈希函数\cite{jenkins1997hash}，在接下来的研究中，他对其研究成果进行了扩展，提出了名为lookup2和lookup3的哈希函数\cite{jenkins2006function}。lookup3哈希函数被有关学者认为是第一款“现代的”哈希函数。
2008年，Austin Appleby发布了名为MurmurHash的哈希函数\cite{Murmurhash}。
最新的Murmurhash具有两倍于lookup3的性能。由于其卓越的运算速度和统计特性，MurmurHash得到广泛应用。
2011年，发布了两款高性能的哈希函数：一款是Google发布的CityHash\cite{cityhash}；另一款是由Jenkins提出的SpookyHash\cite{jenkins2012spookyhash}。这两款哈希函数都是基于MurmurHash，其性能的提升在很大程度上得益于更高的指令集并行。
这两款哈希函数都有两倍于MurmurHash的处理速度，CityHash的速度源于SSE 4.2中的CRC32指令。
SpookyHash产生128的输出结果，而CityHash的输出结果更为灵活，可生成64位、128位和256位的哈希值。

\subsection{哈希冲突处理}

处理碰撞的方法大致可以分为两类：一类是\textbf{开放寻址法}(open-addressing)；一类是\textbf{开链法}(separate chaining)。

开放寻址法，所有元素都存放在哈希桶数组内，当需要在哈希表中插入新元素时，将对哈希桶进行扫描，从被直接映射到的哈希桶开始，按照某种探测序列进行扫描，知道找到空闲的哈希桶为止。
当需要查找某个元素时，需要以同样的探测序列进行查找，直到找到所需的元素，或者最终发现元素不在表中为止。
常用于开放寻址法的探测序列有线性探测、二次探测、双重哈希以及Cuckoo哈希。

\textbf{线性探测}。
在线性探测中，进行探测的初始位置由$h(k)$确定，地址增量为$i$，从当前位置开始，若为空，则插入元素，若非空，则探测距离当前位置$i$个单位的位置继续，直到找到空闲的位置或者便利完整个哈希表为止。
为了确保能够遍历到整个哈希表，$i$通常是哈希表容量$m$的相对质数。
利用线性探测计算key的位置的公式如式~\ref{equ:linear_prob}所示:
\begin{equation}
	h(k,i) = (h(k)+i) ~{mod}~m
\label{equ:linear_prob}
\end{equation}
当地址增量$i$等于1时，探测的位置是连续的。
线性探测的性能取决于查找key的位置时进行的探测次数，而探测次数又取决于哈希表的负载因子。
哈希表的负载因子越高，查找一个key的位置时所需的探测次数就越多。
根据Knuth的论证表明\cite{knuth1998art}，使用线性探测法完成一次key的位置探测所需的平均探测次数约为$1/2(1+\frac{1}{1-\alpha})$.


\textbf{二次探测}与线性探测的相关性很高。
二次探测计算key的位置的公式如式~\ref{equ:quad_prob}所示：
\begin{equation}
h(k,i) = (h(k)+c_1 i+c_2i^2)~{mod}~m
\label{equ:quad_prob}
\end{equation}
式中$c_1$和$c_2$均为常数。
Heileman等人的研究表明，当哈希表的大小超过缓存的容量时，使用线性探测的性能要好于使用二次探测\cite{heileman2005caching}。
虽然线性探测通常需要比二次探测执行更多的探测尝试，但是这些尝试具有更高的缓存命中率，从而在整个哈希表的大小超过了缓存容量时表现出更好的整体性能。
另一方面，当哈希表的负载因子较高时，使用二次探测能够获得更好的性能，当然这只是相对而言的，当$\alpha$接近1时，使用二次探测的性能也不理想\cite{}。
同样Knuth对使用二次探测完成一次key的位置的探测所需的平均探测次数进行了估计，约为$1-ln(1-\alpha)-\frac{\alpha}{2}$.

\textbf{双重哈希}，顾名思义就是使用两个哈希函数$h_1$和$h_2$计算需要探测的初始索引值。
计算公式如式~\ref{equ:double}所示：
\begin{equation}
h(k,i) = (h_1(k)+i\cdot h_2(k)) ~{mod}~m
\label{equ:double}
\end{equation}
由于$h_2$提供可变的地址增量，所以双重哈希很好的解决了线性探测和二次探测中的“聚集”问题。
此外，多重碰撞的设置产生比线性或二次探测更为均匀的键值分布。
双重哈希方法的性能也会随着哈希表负载因子的增加而下降。
使用双重哈希完成一次查找所需的平均探测次数为$-\frac{1}{\alpha}ln(1-\alpha)$.

\textbf{Cuckoo哈希}
Cuckoo哈希的特性是当在哈希表中插入新的key时，会将原来存储与该位置上的key排挤到其他的位置上去。
一般设置两个哈希函数$h_1(k)$和$h_2(k)$。
当插入新的key时，可以任意的选择在$h_1(k)$和$h_2(k)$位置上进行插入。
如果插入的位置上已经存有了$k_1$，则将$k$覆盖$k_1$，然后将$k_1$存入到$h_1(k)$和$h_2(k)$中空闲的位置。
如果$h_1(k)$和$h_2(k)$中都没有空闲位置，则继续上述过程，直到所有的key都找到了合适的位置或者执行替换的次数达到上限\cite{pagh2004cuckoo,erlingsson2006cool}。
Pagh等人的研究表明，要保持Cuckoo哈希的最优性能，需要确保$\alpha\leq 0.5$\cite{pagh2004cuckoo}；Erlingsson等人提出了一种广义的Cuckoo哈希技术\cite{erlingsson2006cool}，能够使哈希表的负载因子达到99\%时仍然具有较好的性能;
Ross等人通过应用单指令多数据流(SIMD)指令挖掘并行性并消除探测函数内的分支指令实现了对广义Cuckoo哈希方法的性能优化\cite{ross2007efficient}。

上述的几种常用的开放寻址法中，性能都与哈希表的负载因子相关。
负载因子越高，完成一次查找所需的探测次数就越多，性能也随之受到影响。
实际上，即便是再好的哈希函数，在负载因子大于0.7之后性能会急剧下降。

另一类常用的冲突处理方法称为开链法。
开链法引入额外的数据结构，比如链表，用于解决哈希冲突问题。
每一个哈希桶都是独立的，所有经过哈希之后具有相同索引值的元素都放在同一个哈希桶中，这些元素通过链表进行管理。
所以，使用开链法的哈希表能够存储的元素的个数大于哈希桶的数目，也就是说它的负载因子可以大于1.
对哈希表执行操作的时间等于找到相应的哈希桶的时间加上对列表进行操作的时间。
虽说使用开链法的哈希表的负载因子可以大于1，并不意味着链入同一个哈希桶中的元素的个数可以是无限制的，如果某一个位置冲突过多的话，插入的时间复杂度将退化为O(N)，这种退化将引起缓存未命中率的骤然升高\cite{black1998graph}。
因此，每个哈希桶内元素的个数应在3个以内。

两种方法各有优劣，开放寻址在解决当前冲突的情况下可能会导致新的冲突，而开链不会产生这种问题。另一方面开链的局部性较之开放寻址法要差，在程序运行过程中可能引起操作系统的缺页中断，从而导致系统颠簸。

哈希表被广泛实现系统层和应用层软件，被集成到编程语言如Java，Python等，还可以用来实现关联数组，数据库索引，缓存，集合等。
哈希表的高效性使其具有重要的研究价值和应用价值。

\section{基于软件技术的同步方法研究}

在并发哈希的设计中，除了选用的哈希函数、所采用的冲突处理方案以及数据结构上的差异造成性能上的差别之外，另一个重要的因素是选取的同步方案。
并发数据结构的设计中，常用的同步方法大致可以划分成三类：锁方法、内存屏障技术和事务内存。

\subsection{阻塞技术}
\subsubsection{锁方法}
在并发数据结构中锁用于保证多个线程对数据结构的互斥访问，以避免线程间发生“错误的”交错，从而产生预期之外的结果。
设计锁算法的关键问题是当线程$t_1$试图申请线程$t_2$已经占有的锁时，$t_1$要采取的行动。
在单处理器系统上，出现这种情况时唯一明智的处理方式是将处理器让给$t_1$即可。
但是在多处理器系统上，因为锁可能在不长的时间内会被另一个处理器上执行的线程释放，所以使$t_1$反复尝试获取锁有助于提升性能。
这种使线程不断的尝试获取锁的技术称为\textbf{自旋锁(spinlock)}。
在线程执行期间很难预测该线程会持有锁多长时间，所以很难在阻塞技术和自旋锁之间做出选择。
如果操作系统直接支持锁，诸如当前持有锁的线程等信息能够用于做出抉择。

简单的自旋锁重复使用同步原语，如比较和交换(swap-and-change，CAS)，以原子方式将锁从无主状态转换到被占有状态。 如果锁的设计不够仔细，自旋锁会引起激烈的锁竞争，从而对性能造成严重影响。
一种简单的降低锁竞争的方法是引入指数退避(exponential backoff)机制\cite{agarwal1989adaptive}。
使用这种方法获取锁失败的线程在进行重试之前会等待一段时间；
失败的次数越多，等待的时间越长，此时线程会及时的“自行分散”，由此降低了线程对锁的争用，同时也减少了由于尝试获取锁失败引起的流量开销。

使用指数退避机制的锁的缺陷是锁可以处于无主状态，而尝试获取该锁的线程都已经执行退避策略，需要等待较长的时间，因此在这段时间内所有的线程都不会前向执行。
解决这个问题方法是使所有申请锁的线程存储在一个队列中，锁被释放后将锁的所有权传递给下一个正在排队的线程。
基于这种方法实现的锁被称为\textbf{队列锁(quenelocks)}。
Anderson\cite{anderson1989performance}和Graunke\cite{graunke1990synchronization}提出了基于阵列的队列锁方法。
之后M.Crummey和T.Scott\cite{mellor1991algorithms}对他们的方法进行改进实现了的基于列表的MCS队列锁，以及由Craig和E.Hagersten等人\cite{craig1993building,magnusson1994queue}提出的CLH队列锁。

使用CLH锁的线程形成一个虚拟的节点链表，每个节点都包含一个$done$标志；某个线程只有当列表中它的前继节点的$done$标志被触发后才进入临界区。
为了获得锁，线程创建一个节点，将它的$done$标志设置为$false$，表示它还没有释放临界区，并且使用同步原语(如CAS)将它自己的节点放在列表的尾部，同时确定其前继节点。
随后，该线程在其前继节点的$done$标志上自旋。
值得一提的是，每个线程的自旋过程发生在不同的内存位置，因此，在基于缓存的体系结构中，当某个线程设置其$done$标志以通知队列中的下一个线程可以进入临界区时，所有其他正在自旋的线程的$done$标志不会被修改，这些线程将继续 在本地缓存行上自旋，而不会产生额外的内存流量。
这在很大程度上减少了争用，提升了扩展性。
但是，如果使用这种锁算法的程序运行在非一致性的NUMA平台上，某些线程不得不在远程内存结点上进行自旋，这样无疑会消耗更多的内存流量。
使用MCS队列锁\cite{mellor1991algorithms}通过将线程自旋的位置限定在该线程自身结点的$done$标志来解决NUMA平台上的问题。

此外，为了迎合特定的数据结构的数据读取特性在后续的演化中出现了一些标准锁方法的变体。
队列锁算法中出现了一种具有“可中止的”特性的版本，它允许正在申请锁的线程放弃等待，比如在实时性要求较高的应用中延迟超过极限值时\cite{scott2002non,scott2001scalable}，或者线程需要从死锁中进行恢复时。
M.Scott等人提出了抢占安全锁(preemption-safe locks)\cite{michael1998nonblocking}，它通过确保队列中被抢占的线程不会阻止锁被授予另一个正在运行的线程，从而试图减少锁抢占对性能造成的负面影响。

许多数据结构有并发读取的需求，因此，这样的读写锁只允许线程对临界区内的数据进行读取而不能修改，如果当前临界区没有写者线程进行操作，则允许多个读者线程并发访问。
M.Crummey和T.Scott等人提出的读写队列锁算法是基于MCS队列锁并且使用读计数器和指向写者节点的指针实现的\cite{mellor1991scalable}。
文献\cite{krieger1993fair}中提出了一种通过设置队列节点的双链表，每个节点都有自己的简单“迷你锁”，读者通过获取其相邻节点的迷你锁并重定向双链表的指针来将自己从queuelock列表中移除。

锁在并发数据结构的设计中的重要性不言而喻。
选取锁的标准一是要与应用场景结合；二是要能提供充分的扩展性。
对于哈希表这种读密集型的数据结构

\subsection{屏障技术}

屏障是这样一种机制，所有的提前执行到代码中指定的某些位置的线程悬停，只有当所有线程都到达这个点时才允许它们继续执行。 当访问数据结构或应用程序需要划分成若干个不相互重叠的执行阶段时，就需要使用内存障碍。
例如，并行垃圾收集器的标记和扫描阶段。
此外，在本文中设计的统一的并发哈希表测试框架就用到了内存屏障。
并发哈希表在测试之前需要进行初始化，也就是在哈希表内插入一些元素，让哈希表的密度达到预定的值。
初始化的过程使用多线程共同完成，由于不需要删除元素，所以这个过程在数据量大的测试集中采用多线程会节约初始化时间。
此时如果有现成提前完成了初始化的任务，它会触碰到内存屏障，必须要等待所有参与初始化的线程全部完成之后再往下执行。

实现屏障的一个简单方法是使用初始化一个值为线程总数的计数器：每个线程在到达屏障后递减计数器，然后自旋，等待计数器变为零，然后继续往下执行。
这种直观的实现方式可能引起两个方面的问题：
\begin{itemize}
	\item 当使用相同的pass/stop技术实现了多个串行屏障时，当有线程到达第二个屏障而在第一个屏障内还有一些线程没有完成时，会出现死锁；
	\item 由于所有的线程反复的查询全局变量的状态，导致通信流量大，从而对程序的可扩展性造成影响。
\end{itemize}
针对上述问题，实现了专门的屏障技术，可以让线程在不同的位置自旋\cite{brooks1986butterfly,hensgen1988two,mellor1992fast,tseng2016scalable}。
或者也可以使用Dijkstra和Scholten风格的发散计算树来实现屏障\cite{dijkstra1980termination}。在这种方法中，每个线程都是二叉树中一个节点的所有者。
线程等候它的子节点的到达，然后通知该线程的父节点以表明自己的子节点已到达。一旦所有线程都已到达，树的根节点通过向下发送释放消息释放所有线程。
除了通过软件技术实现的屏障之外，还有通过硬件实现了上述的屏障功能\cite{solihin2015fundamentals}。

\subsection{无阻塞技术}
如前文所述，使用无阻塞编程是为了克服使用锁方法带来的若干问题。
无阻塞技术包含几类条件——无等待\cite{lamport1974new,herlihy1991wait}，无锁\cite{herlihy1991wait}和无阻碍\cite{herlihy2003obstruction}。
三类条件由强到弱排列顺序依次为无等待强于无锁，无锁强于无阻碍。
但是这三类条件都强于使用诸如锁之类的阻塞结构。
虽然更强的前向条件是可取的，但是通常情况下实现较弱的保障条件更加容易、效率更高，并且易于设计和正确性验证。
所以，在实际的应用中，研究人员往往通过采取退避策略\cite{agarwal1989adaptive}或使用更复杂的竞争管理技术\cite{herlihy2003software}来补偿较弱的前向条件。


\section{非一致性内存访问的内存管理相关研究}

\subsection{XX研究}
\label{sec:}

\subsection{XX技术}

\section{事务内存相关研究}

\subsection{实现事务内存的相关技术}
% 相关研究
\subsection{基于事务内存的并发数据结构}

\section{集合元素查询算法}

\subsection{布隆过滤器算法}
在数据库、缓存、路由器和存储系统中通常需要使用判定一个元素是否存在在某个集合内，这种判断允许一定的误报率。
进行这种成员关系判定布隆过滤器(bloom filter)是使用得最多的一种数据结构\cite{bloom1970space}。
布隆过滤器因其高效的内存效率而备受关注。

\subsection{Cuckoo哈希算法}



\section{本章小结}


